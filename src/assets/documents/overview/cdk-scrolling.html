<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p">The <code class="docs-markdown-code">scrolling</code> package provides helpers for directives that react to scroll events.</p><h3 id="cdkscrollable-and-scrolldispatcher" class="docs-header-link docs-markdown-h3"><span header-link="cdkscrollable-and-scrolldispatcher"></span> cdkScrollable and ScrollDispatcher</h3><p class="docs-markdown-p">The <code class="docs-markdown-code">cdkScrollable</code> directive and the <code class="docs-markdown-code">ScrollDispatcher</code> service together allow components to react to scrolling in any of its ancestor scrolling containers.</p><p class="docs-markdown-p">The <code class="docs-markdown-code">cdkScrollable</code> directive should be applied to any element that acts as a scrolling container. This marks the element as a <code class="docs-markdown-code">Scrollable</code> and registers it with the <code class="docs-markdown-code">ScrollDispatcher</code>. The dispatcher, then, allows components to share both event listeners and knowledge of all of the scrollable containers in the application.</p><h3 id="viewportruler" class="docs-header-link docs-markdown-h3"><span header-link="viewportruler"></span> ViewportRuler</h3><p class="docs-markdown-p">The <code class="docs-markdown-code">ViewportRuler</code> is a service that can be injected and used to measure the bounds of the browser viewport.</p><h3 id="virtual-scrolling" class="docs-header-link docs-markdown-h3"><span header-link="virtual-scrolling"></span> Virtual scrolling</h3><p class="docs-markdown-p">The <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code> displays large lists of elements performantly by only rendering the items that fit on-screen. Loading hundreds of elements can be slow in any browser; virtual scrolling enables a performant way to simulate all items being rendered by making the height of the container element the same as the height of total number of elements to be rendered, and then only rendering the items in view. Virtual scrolling is different from strategies like infinite scroll where it renders a set amount of elements and then when you hit the end renders the rest.</p><h4 id="creating-items-in-the-viewport" class="docs-header-link docs-markdown-h4"><span header-link="creating-items-in-the-viewport"></span> Creating items in the viewport</h4><p class="docs-markdown-p"><code class="docs-markdown-code">*cdkVirtualFor</code> replaces <code class="docs-markdown-code">*ngFor</code> inside of a <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code>, supporting the exact same API as <a href="https://angular.io/api/common/NgForOf" class="docs-markdown-a"><code class="docs-markdown-code">*ngFor</code></a>. The simplest usage just specifies the list of items:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">cdkVirtualFor</span>=<span class="hljs-string">"let item of items"</span>&gt;</span>{{item}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><p class="docs-markdown-p"><code class="docs-markdown-code">*cdkVirtualFor</code> makes the following context variables available to the template:</p><table class="docs-markdown-table"><thead><tr class="docs-markdown-tr"><th class="docs-markdown-th">Context variable</th><th class="docs-markdown-th">Description</th></tr></thead><tbody class="docs-markdown-tbody"><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">index</code></td><td class="docs-markdown-td">The index of the item in the data source.</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">count</code></td><td class="docs-markdown-td">The total number of items in the data source.</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">first</code></td><td class="docs-markdown-td">Whether this is the first item in the data source.</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">last</code></td><td class="docs-markdown-td">Whether this is the last item in the data source.</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">even</code></td><td class="docs-markdown-td">Whether the <code class="docs-markdown-code">index</code> is even.</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">odd</code></td><td class="docs-markdown-td">Whether the <code class="docs-markdown-code">index</code> is odd.</td></tr></tbody></table><p class="docs-markdown-p">All of these apply to the index of the item in the data source, not the index in the rendered portion of the data.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">cdkVirtualFor</span>=<span class="hljs-string">"let item of items;
                       let index = index;
                       let count = count"</span>&gt;</span>
    {{item}} ({{index}} of {{count}})
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><p class="docs-markdown-p">A <code class="docs-markdown-code">trackBy</code> function can be specified and works the same as the <code class="docs-markdown-code">*ngFor</code> <code class="docs-markdown-code">trackBy</code>. The <code class="docs-markdown-code">index</code> passed to the tracking function will be the index in the data source, not the index in the rendered portion.</p><h5 class="docs-markdown-h5">View recycling</h5><p class="docs-markdown-p">To improve rendering performance, <code class="docs-markdown-code">*cdkVirtualFor</code> caches previously created views after they are no longer needed. When a new view would normally be created, a cached view is reused instead. The size of the view cache can be adjusted via the <code class="docs-markdown-code">templateCacheSize</code> property; setting this size to <code class="docs-markdown-code">0</code> disables caching. If your templates are expensive in terms of memory you may wish to reduce this number to avoid spending too much memory on the template cache.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">cdkVirtualFor</span>=<span class="hljs-string">"let item of items; templateCacheSize: 0"</span>&gt;</span>{{item}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><h5 class="docs-markdown-h5">Specifying data</h5><p class="docs-markdown-p"><code class="docs-markdown-code">*cdkVirtualFor</code> accepts data from an <code class="docs-markdown-code">Array</code>, <code class="docs-markdown-code">Observable&lt;Array&gt;</code>, or <code class="docs-markdown-code">DataSource</code>. The <code class="docs-markdown-code">DataSource</code> for the virtual scroll is the same one used by the table and tree components. A <code class="docs-markdown-code">DataSource</code> is simply an abstract class that has two methods: <code class="docs-markdown-code">connect</code> and <code class="docs-markdown-code">disconnect</code>. The <code class="docs-markdown-code">connect</code> method will be called by the virtual scroll viewport to receive a stream that emits the data array that should be rendered. The viewport will call <code class="docs-markdown-code">disconnect</code> when the viewport is destroyed, which may be the right time to clean up any subscriptions that were registered during the connect process.</p><h4 id="scrolling-over-fixed-size-items" class="docs-header-link docs-markdown-h4"><span header-link="scrolling-over-fixed-size-items"></span> Scrolling over fixed size items</h4><p class="docs-markdown-p">When all items are the same fixed size, you can use the <code class="docs-markdown-code">FixedSizeVirtualScrollStrategy</code>. This can be easily added to your viewport using the <code class="docs-markdown-code">itemSize</code> directive. The advantage of this constraint is that it allows for better performance, since items do not need to be measured as they are rendered.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><p class="docs-markdown-p">The fixed size strategy also supports setting the buffer size, i.e. the number of items rendered beyond the edge of the viewport. This can be adjusted by setting the <code class="docs-markdown-code">bufferSize</code> input. If <code class="docs-markdown-code">bufferSize</code> is not specified it defaults to 5 items.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">bufferSize</span>=<span class="hljs-string">"1"</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><p class="docs-markdown-p">Other virtual scrolling strategies can be implemented by extending <code class="docs-markdown-code">VirtualScrollStrategy</code>. An autosize strategy that works on elements of differing sizes is currently being developed in <code class="docs-markdown-code">@angular/cdk-experimental</code>, but it is not ready for production use yet.</p><h3 id="viewport-orientation" class="docs-header-link docs-markdown-h3"><span header-link="viewport-orientation"></span> Viewport orientation</h3><p class="docs-markdown-p">The virtual-scroll viewport defaults to a vertical orientation, but can also be set to <code class="docs-markdown-code">orientation="horizontal"</code>. When changing the orientation, ensure that the item are laid out horizontally via CSS. To do this you may want to target CSS at <code class="docs-markdown-code">.cdk-virtual-scroll-content-wrapper</code> which is the wrapper element that contains the rendered content.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><h3 id="elements-with-parent-tag-requirements" class="docs-header-link docs-markdown-h3"><span header-link="elements-with-parent-tag-requirements"></span> Elements with parent tag requirements</h3><p class="docs-markdown-p">Some HTML elements such as <code class="docs-markdown-code">&lt;tr&gt;</code> and <code class="docs-markdown-code">&lt;li&gt;</code> have limitations on the kinds of parent elements they can be placed inside. To enable virtual scrolling over these type of elements, place the elements in their proper parent, and then wrap the whole thing in a <code class="docs-markdown-code">cdk-virtual-scroll-viewport</code>. Be careful that the parent does not introduce additional space (e.g. via <code class="docs-markdown-code">margin</code> or <code class="docs-markdown-code">padding</code>) as it will interfere with the scrolling.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">cdkVirtualFor</span>=<span class="hljs-string">"let row of rows"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{row.first}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{row.second}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre></div></body></html>